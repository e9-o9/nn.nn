â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Z++ Formal Specification: Integration Contracts                            â”‚
â”‚                                                                             â”‚
â”‚ This specification formalizes the external interfaces and integration      â”‚
â”‚ contracts for the neural network system, including tensor operations,      â”‚
â”‚ serialization, and external API boundaries.                                â”‚
â”‚                                                                             â”‚
â”‚ Depends on: data_model.zpp, system_state.zpp, operations.zpp               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 1: TENSOR OPERATION CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ TensorOperation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input : Tensor                                                              â”‚
â”‚ output : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ -- Base contract for all tensor operations                                 â”‚
â”‚ error = false â‡’ output.data â‰  []                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Base schema for tensor operations with error handling.

â”Œâ”€ ElementwiseOperation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TensorOperation                                                             â”‚
â”‚                                                                             â”‚
â”‚ error = false â‡’ TensorCompatible(input, output)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Element-wise operations preserve shape.

â”Œâ”€ TensorAdd â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ t1, t2 : Tensor                                                             â”‚
â”‚ result : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ TensorCompatible(t1, t2) â‡’                                                  â”‚
â”‚     (error = false âˆ§ TensorCompatible(result, t1) âˆ§                        â”‚
â”‚      âˆ€ i : dom t1.data â€¢ result.data(i) = t1.data(i) + t2.data(i))        â”‚
â”‚ Â¬TensorCompatible(t1, t2) â‡’ error = true                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Element-wise tensor addition with shape compatibility check.

â”Œâ”€ TensorMultiply â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ t1, t2 : Tensor                                                             â”‚
â”‚ result : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ TensorCompatible(t1, t2) â‡’                                                  â”‚
â”‚     (error = false âˆ§ TensorCompatible(result, t1) âˆ§                        â”‚
â”‚      âˆ€ i : dom t1.data â€¢ result.data(i) = t1.data(i) Ã— t2.data(i))        â”‚
â”‚ Â¬TensorCompatible(t1, t2) â‡’ error = true                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Element-wise tensor multiplication (Hadamard product).

â”Œâ”€ MatrixMultiply â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ t1, t2 : Tensor                                                             â”‚
â”‚ result : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ t1.ndim = 2 âˆ§ t2.ndim = 2 âˆ§ t1.shape(2) = t2.shape(1) â‡’                   â”‚
â”‚     (error = false âˆ§ result.shape = [t1.shape(1), t2.shape(2)] âˆ§          â”‚
â”‚      âˆ€ i : 1..t1.shape(1), j : 1..t2.shape(2) â€¢                           â”‚
â”‚          result.data(i, j) = Î£ [k : 1..t1.shape(2) |                       â”‚
â”‚              t1.data(i, k) Ã— t2.data(k, j)])                               â”‚
â”‚ Â¬(t1.ndim = 2 âˆ§ t2.ndim = 2 âˆ§ t1.shape(2) = t2.shape(1)) â‡’ error = true  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Matrix multiplication with dimension compatibility checking.

â”Œâ”€ TensorTranspose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input : Tensor                                                              â”‚
â”‚ output : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ input.ndim = 2 â‡’                                                            â”‚
â”‚     (error = false âˆ§ output.shape = [input.shape(2), input.shape(1)] âˆ§    â”‚
â”‚      âˆ€ i : 1..input.shape(1), j : 1..input.shape(2) â€¢                     â”‚
â”‚          output.data(j, i) = input.data(i, j))                             â”‚
â”‚ input.ndim â‰  2 â‡’ error = true                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Matrix transpose (2D tensors only).

â”Œâ”€ TensorReshape â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input : Tensor                                                              â”‚
â”‚ targetShape : Shape                                                         â”‚
â”‚ output : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ âˆ(input.shape) = âˆ(targetShape) â‡’                                          â”‚
â”‚     (error = false âˆ§ output.shape = targetShape âˆ§                          â”‚
â”‚      output.data = input.data)                                             â”‚
â”‚ âˆ(input.shape) â‰  âˆ(targetShape) â‡’ error = true                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Reshapes tensor preserving total element count.

â”Œâ”€ TensorSlice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input : Tensor                                                              â”‚
â”‚ dimension : â„•                                                               â”‚
â”‚ startIndex : â„•                                                              â”‚
â”‚ endIndex : â„•                                                                â”‚
â”‚ output : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ 1 â‰¤ dimension â‰¤ input.ndim âˆ§ 1 â‰¤ startIndex â‰¤ endIndex â‰¤ input.shape(dimension) â‡’ â”‚
â”‚     (error = false âˆ§                                                        â”‚
â”‚      output.ndim = input.ndim âˆ§                                            â”‚
â”‚      âˆ€ d : 1..input.ndim â€¢                                                 â”‚
â”‚          output.shape(d) = if d = dimension                                â”‚
â”‚                            then endIndex - startIndex + 1                   â”‚
â”‚                            else input.shape(d))                             â”‚
â”‚ -- Otherwise error                                                         â”‚
â”‚ Â¬(1 â‰¤ dimension â‰¤ input.ndim âˆ§ 1 â‰¤ startIndex â‰¤ endIndex â‰¤ input.shape(dimension)) â‡’ â”‚
â”‚     error = true                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Extracts a slice from a tensor along a specified dimension.

â”Œâ”€ TensorConcatenate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ tensors : seq Tensor                                                        â”‚
â”‚ dimension : â„•                                                               â”‚
â”‚ output : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ #tensors > 0 âˆ§ 1 â‰¤ dimension â‰¤ tensors(1).ndim âˆ§                          â”‚
â”‚ (âˆ€ i, j : dom tensors â€¢ tensors(i).ndim = tensors(j).ndim âˆ§               â”‚
â”‚     âˆ€ d : 1..tensors(1).ndim â€¢ d â‰  dimension â‡’                            â”‚
â”‚         tensors(i).shape(d) = tensors(j).shape(d)) â‡’                       â”‚
â”‚     (error = false âˆ§                                                        â”‚
â”‚      output.ndim = tensors(1).ndim âˆ§                                       â”‚
â”‚      âˆ€ d : 1..output.ndim â€¢                                                â”‚
â”‚          output.shape(d) = if d = dimension                                â”‚
â”‚                            then Î£ [t : ran tensors | t.shape(d)]           â”‚
â”‚                            else tensors(1).shape(d))                        â”‚
â”‚ -- Otherwise error                                                         â”‚
â”‚ Â¬(#tensors > 0 âˆ§ 1 â‰¤ dimension â‰¤ tensors(1).ndim âˆ§ ...) â‡’ error = true   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Concatenates multiple tensors along a specified dimension.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 2: MATHEMATICAL FUNCTION CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ ActivationFunction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ input : â„                                                                   â”‚
â”‚ output : â„                                                                  â”‚
â”‚ derivative : â„                                                              â”‚
â”‚                                                                             â”‚
â”‚ -- All activation functions must provide derivative                        â”‚
â”‚ -- Derivative is with respect to input                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Contract for scalar activation functions.

â”Œâ”€ SigmoidFunction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ActivationFunction                                                          â”‚
â”‚                                                                             â”‚
â”‚ output = 1 / (1 + e^(-input))                                              â”‚
â”‚ 0 < output < 1                                                              â”‚
â”‚ derivative = output Ã— (1 - output)                                          â”‚
â”‚ 0 < derivative â‰¤ 0.25                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Sigmoid function and its derivative.

â”Œâ”€ TanhFunction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ActivationFunction                                                          â”‚
â”‚                                                                             â”‚
â”‚ output = (e^input - e^(-input)) / (e^input + e^(-input))                  â”‚
â”‚ -1 < output < 1                                                             â”‚
â”‚ derivative = 1 - outputÂ²                                                    â”‚
â”‚ 0 < derivative â‰¤ 1                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Hyperbolic tangent function and its derivative.

â”Œâ”€ ReLUFunction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ActivationFunction                                                          â”‚
â”‚                                                                             â”‚
â”‚ output = max(0, input)                                                      â”‚
â”‚ output â‰¥ 0                                                                  â”‚
â”‚ derivative = if input > 0 then 1 else 0                                    â”‚
â”‚ derivative âˆˆ {0, 1}                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ReLU function and its derivative (sub-gradient at 0).

â”Œâ”€ SoftmaxFunction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ inputs : seq â„                                                              â”‚
â”‚ outputs : seq â„                                                             â”‚
â”‚ jacobian : seq (seq â„)                                                      â”‚
â”‚                                                                             â”‚
â”‚ #inputs > 0 âˆ§ #outputs = #inputs                                           â”‚
â”‚ let expSum == Î£ [x : ran inputs | e^x] in                                  â”‚
â”‚     âˆ€ i : dom inputs â€¢ outputs(i) = e^(inputs(i)) / expSum                â”‚
â”‚ âˆ€ i : dom outputs â€¢ outputs(i) > 0                                         â”‚
â”‚ Î£(outputs) = 1.0                                                            â”‚
â”‚ -- Jacobian: âˆ‚yáµ¢/âˆ‚xâ±¼ = yáµ¢(Î´áµ¢â±¼ - yâ±¼)                                       â”‚
â”‚ #jacobian = #outputs âˆ§                                                      â”‚
â”‚ âˆ€ i : dom jacobian â€¢ #jacobian(i) = #outputs âˆ§                             â”‚
â”‚     âˆ€ j : dom jacobian(i) â€¢                                                 â”‚
â”‚         jacobian(i)(j) = outputs(i) Ã— (if i = j then 1 - outputs(j)        â”‚
â”‚                                        else -outputs(j))                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Softmax function with full Jacobian matrix for backpropagation.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 3: SERIALIZATION CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ SerializedFormat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SerializedFormat ::= JSON | Binary | Lua | Prolog                           â”‚
â”‚                                                                             â”‚
â”‚ Supported serialization formats                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ SerializedData â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SerializedData == seq Byte                                                  â”‚
â”‚ Byte == {n : â„¤ | 0 â‰¤ n â‰¤ 255}                                              â”‚
â”‚                                                                             â”‚
â”‚ Raw byte sequence representing serialized objects                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ TensorSerialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ tensor : Tensor                                                             â”‚
â”‚ format : SerializedFormat                                                   â”‚
â”‚ serialized : SerializedData                                                 â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ error = false â‡’ #serialized > 0                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Contract for serializing tensors to various formats.

â”Œâ”€ TensorDeserialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ serialized : SerializedData                                                 â”‚
â”‚ format : SerializedFormat                                                   â”‚
â”‚ tensor : Tensor                                                             â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ error = false â‡’                                                             â”‚
â”‚     (tensor.shape â‰  [] âˆ§ #tensor.data = âˆ(tensor.shape))                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Contract for deserializing tensors from various formats.

â”Œâ”€ RoundTripInvariant â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ original : Tensor                                                           â”‚
â”‚ format : SerializedFormat                                                   â”‚
â”‚ serialized : SerializedData                                                 â”‚
â”‚ deserialized : Tensor                                                       â”‚
â”‚                                                                             â”‚
â”‚ TensorSerialization[original/tensor, serialized/serialized] âˆ§              â”‚
â”‚ TensorDeserialization[serialized/serialized, deserialized/tensor] â‡’        â”‚
â”‚     (deserialized.shape = original.shape âˆ§                                 â”‚
â”‚      âˆ€ i : dom original.data â€¢                                             â”‚
â”‚          |deserialized.data(i) - original.data(i)| < Îµ)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Serialization round-trip preserves tensor data within tolerance Îµ.

â”Œâ”€ ModelSerialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemState                                                                 â”‚
â”‚ format : SerializedFormat                                                   â”‚
â”‚ serialized : SerializedData                                                 â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ error = false â‡’                                                             â”‚
â”‚     (#serialized > 0 âˆ§                                                      â”‚
â”‚      -- Serialized data includes topology and all parameters               â”‚
â”‚      âˆ€ mid : dom topology.registry.modules,                                â”‚
â”‚        pname : dom topology.registry.modules(mid).parameters â€¢              â”‚
â”‚          -- Parameter data is included in serialized form                  â”‚
â”‚          true)                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Contract for serializing complete model state.

â”Œâ”€ ModelDeserialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemState'                                                                â”‚
â”‚ serialized : SerializedData                                                 â”‚
â”‚ format : SerializedFormat                                                   â”‚
â”‚ error : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ error = false â‡’                                                             â”‚
â”‚     (topology'.registry.modules â‰  âˆ… âˆ§                                       â”‚
â”‚      topology'.rootModule âˆˆ dom topology'.registry.modules âˆ§               â”‚
â”‚      -- All modules have consistent modes                                  â”‚
â”‚      âˆ€ mid : dom topology'.registry.modules â€¢                               â”‚
â”‚          topology'.registry.modules(mid).mode = mode')                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Contract for deserializing model state, ensuring validity.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 4: FILE I/O CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ FilePath â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FilePath == seq Char                                                        â”‚
â”‚                                                                             â”‚
â”‚ String representing file system path                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ SaveModel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ÎSystemState                                                                â”‚
â”‚ path? : FilePath                                                            â”‚
â”‚ format? : SerializedFormat                                                  â”‚
â”‚ success! : ğ”¹                                                                â”‚
â”‚                                                                             â”‚
â”‚ #path? > 0                                                                  â”‚
â”‚ success! â‡’                                                                  â”‚
â”‚     -- File written successfully with serialized model                     â”‚
â”‚     âˆƒ data : SerializedData â€¢                                               â”‚
â”‚         ModelSerialization[format?/format, data/serialized]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Saves model to file system in specified format.

â”Œâ”€ LoadModel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemState'                                                                â”‚
â”‚ path? : FilePath                                                            â”‚
â”‚ format? : SerializedFormat                                                  â”‚
â”‚ success! : ğ”¹                                                                â”‚
â”‚                                                                             â”‚
â”‚ #path? > 0                                                                  â”‚
â”‚ success! â‡’                                                                  â”‚
â”‚     -- File read successfully and model deserialized                       â”‚
â”‚     âˆƒ data : SerializedData â€¢                                               â”‚
â”‚         ModelDeserialization[data/serialized, format?/format]               â”‚
â”‚     âˆ§ -- Loaded model passes all system invariants                         â”‚
â”‚       -- (enforced by SystemState schema)                                  â”‚
â”‚       true                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Loads model from file system in specified format.

â”Œâ”€ SaveCheckpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ÎSystemState                                                                â”‚
â”‚ path? : FilePath                                                            â”‚
â”‚ success! : ğ”¹                                                                â”‚
â”‚                                                                             â”‚
â”‚ success! â‡’                                                                  â”‚
â”‚     -- Checkpoint includes model, optimizer state, and training progress   â”‚
â”‚     âˆƒ modelData, optimizerData : SerializedData â€¢                           â”‚
â”‚         ModelSerialization[modelData/serialized] âˆ§                          â”‚
â”‚         -- Optimizer state serialized                                      â”‚
â”‚         -- Training epoch, batch, losses serialized                        â”‚
â”‚         true                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Saves complete training checkpoint for resumption.

â”Œâ”€ LoadCheckpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemState'                                                                â”‚
â”‚ path? : FilePath                                                            â”‚
â”‚ success! : ğ”¹                                                                â”‚
â”‚                                                                             â”‚
â”‚ success! â‡’                                                                  â”‚
â”‚     -- Model, optimizer, and training state restored                       â”‚
â”‚     LoadModel[path?/path?, success!/success!] âˆ§                             â”‚
â”‚     training'.currentEpoch â‰¥ 0 âˆ§                                           â”‚
â”‚     training'.currentBatch â‰¥ 0                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Loads training checkpoint, restoring full state.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 5: DATASET LOADING CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ DataSource â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DataSource ::= File | Database | Stream | Memory                            â”‚
â”‚                                                                             â”‚
â”‚ Types of data sources for dataset loading                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ LoadDataset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Dataset'                                                                    â”‚
â”‚ source? : DataSource                                                        â”‚
â”‚ path? : FilePath                                                            â”‚
â”‚ success! : ğ”¹                                                                â”‚
â”‚                                                                             â”‚
â”‚ success! â‡’                                                                  â”‚
â”‚     (size' > 0 âˆ§                                                            â”‚
â”‚      #samples' = size' âˆ§                                                    â”‚
â”‚      -- All samples have consistent shapes (Dataset invariant)             â”‚
â”‚      âˆ€ i, j : dom samples' â€¢                                               â”‚
â”‚          samples'(i).input.shape = samples'(j).input.shape âˆ§               â”‚
â”‚          samples'(i).target.shape = samples'(j).target.shape)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Loads dataset from specified source with validation.

â”Œâ”€ ShuffleDataset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Î”Dataset                                                                    â”‚
â”‚ seed? : â„•                                                                   â”‚
â”‚                                                                             â”‚
â”‚ size' = size                                                                â”‚
â”‚ -- samples' is a permutation of samples                                    â”‚
â”‚ âˆ€ s : ran samples â€¢ s âˆˆ ran samples'                                       â”‚
â”‚ âˆ€ s : ran samples' â€¢ s âˆˆ ran samples                                       â”‚
â”‚ -- Shape consistency maintained                                            â”‚
â”‚ âˆ€ i, j : dom samples' â€¢                                                     â”‚
â”‚     samples'(i).input.shape = samples'(j).input.shape âˆ§                    â”‚
â”‚     samples'(i).target.shape = samples'(j).target.shape                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Randomly shuffles dataset samples using specified seed.

â”Œâ”€ SplitDataset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ÎDataset                                                                    â”‚
â”‚ ratio? : â„                                                                  â”‚
â”‚ trainSet! : Dataset                                                         â”‚
â”‚ validSet! : Dataset                                                         â”‚
â”‚                                                                             â”‚
â”‚ 0 < ratio? < 1                                                              â”‚
â”‚ let splitIndex == âŒŠratio? Ã— sizeâŒ‹ in                                       â”‚
â”‚     trainSet!.samples = samples[1..splitIndex] âˆ§                            â”‚
â”‚     validSet!.samples = samples[splitIndex+1..size] âˆ§                       â”‚
â”‚     trainSet!.size + validSet!.size = size                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Splits dataset into training and validation sets by ratio.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 6: NUMERICAL STABILITY CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ NumericalCheck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ value : â„                                                                   â”‚
â”‚ isFinite : ğ”¹                                                                â”‚
â”‚ isNaN : ğ”¹                                                                   â”‚
â”‚ isInf : ğ”¹                                                                   â”‚
â”‚                                                                             â”‚
â”‚ isFinite â‡” Â¬isNaN âˆ§ Â¬isInf                                                 â”‚
â”‚ isNaN â‡” value â‰  value                                                      â”‚
â”‚ isInf â‡” |value| = âˆ                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Checks for numerical issues in floating-point values.

â”Œâ”€ ValidateTensor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ tensor : Tensor                                                             â”‚
â”‚ valid : ğ”¹                                                                   â”‚
â”‚ hasNaN : ğ”¹                                                                  â”‚
â”‚ hasInf : ğ”¹                                                                  â”‚
â”‚                                                                             â”‚
â”‚ hasNaN â‡” âˆƒ i : dom tensor.data â€¢ tensor.data(i) â‰  tensor.data(i)          â”‚
â”‚ hasInf â‡” âˆƒ i : dom tensor.data â€¢ |tensor.data(i)| = âˆ                     â”‚
â”‚ valid â‡” Â¬hasNaN âˆ§ Â¬hasInf                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Validates tensor for numerical stability (no NaN or Inf values).

â”Œâ”€ ClipGradients â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Î”SystemState                                                                â”‚
â”‚ maxNorm? : â„                                                                â”‚
â”‚                                                                             â”‚
â”‚ maxNorm? > 0                                                                â”‚
â”‚ computation.gradientValid = true                                            â”‚
â”‚                                                                             â”‚
â”‚ -- Compute total gradient norm                                             â”‚
â”‚ let totalNorm == âˆš(Î£ [mid : dom topology.registry.modules,                â”‚
â”‚                        pname : dom topology.registry.modules(mid).parameters | â”‚
â”‚                        let p == topology.registry.modules(mid).parameters(pname) in â”‚
â”‚                        Î£ [i : dom p.gradient.data | p.gradient.data(i)Â²]]) in â”‚
â”‚     -- If norm exceeds max, scale all gradients                            â”‚
â”‚     totalNorm > maxNorm? â‡’                                                  â”‚
â”‚         let scale == maxNorm? / totalNorm in                                â”‚
â”‚         âˆ€ mid : dom topology'.registry.modules,                             â”‚
â”‚           pname : dom topology'.registry.modules(mid).parameters â€¢          â”‚
â”‚             let p == topology.registry.modules(mid).parameters(pname),     â”‚
â”‚                 p' == topology'.registry.modules(mid).parameters(pname) in â”‚
â”‚             âˆ€ i : dom p.gradient.data â€¢                                    â”‚
â”‚                 p'.gradient.data(i) = p.gradient.data(i) Ã— scale           â”‚
â”‚                                                                             â”‚
â”‚ training' = training                                                        â”‚
â”‚ computation' = computation                                                  â”‚
â”‚ mode' = mode                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Clips gradients by global norm to prevent exploding gradients.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 7: ERROR HANDLING CONTRACTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€ ErrorType â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ErrorType ::= ShapeError | NumericalError | FileError |                     â”‚
â”‚               MemoryError | InvalidState | NotImplemented                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ Result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Result[T] ::= SuccessâŸ¨âŸ¨value : TâŸ©âŸ© | ErrorâŸ¨âŸ¨type : ErrorType, msg : StringâŸ©âŸ© â”‚
â”‚                                                                             â”‚
â”‚ Generic result type with success or error                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ SafeForward â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemState                                                                 â”‚
â”‚ input? : Tensor                                                             â”‚
â”‚ result! : Result[Tensor]                                                    â”‚
â”‚                                                                             â”‚
â”‚ ValidateTensor[input?/tensor] âˆ§                                             â”‚
â”‚ (let valid, _, _ == ValidateTensor in                                       â”‚
â”‚     valid â‡’                                                                 â”‚
â”‚         (âˆƒ S : SystemState, out : Tensor â€¢                                  â”‚
â”‚             CompleteForward[S/SystemState', input?/input?, out/output!] âˆ§   â”‚
â”‚             ValidateTensor[out/tensor] âˆ§                                    â”‚
â”‚             (let valid', _, _ == ValidateTensor in                          â”‚
â”‚                 valid' â‡’ result! = SuccessâŸ¨outâŸ©                            â”‚
â”‚                 âˆ¨ Â¬valid' â‡’ result! = ErrorâŸ¨NumericalError, "..."âŸ©))       â”‚
â”‚     âˆ¨ Â¬valid â‡’ result! = ErrorâŸ¨NumericalError, "Invalid input tensor"âŸ©)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Forward pass with input validation and error handling.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SECTION 8: INTEGRATION CONTRACTS SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This specification defines external interfaces and contracts for:

1. **Tensor Operations**: Element-wise and matrix operations with shape checking
   - TensorAdd, TensorMultiply: Element-wise arithmetic
   - MatrixMultiply: Matrix multiplication with compatibility checks
   - TensorReshape, TensorSlice, TensorConcatenate: Shape manipulation
   - Error handling for shape mismatches

2. **Mathematical Functions**: Activation functions with derivatives
   - SigmoidFunction, TanhFunction, ReLUFunction: Scalar activations
   - SoftmaxFunction: Vector operation with full Jacobian
   - Guaranteed derivative computation for backpropagation

3. **Serialization**: Model persistence with format flexibility
   - TensorSerialization/Deserialization: Individual tensor I/O
   - ModelSerialization/Deserialization: Complete model state
   - RoundTripInvariant: Ensures data preservation
   - Multiple format support (JSON, Binary, Lua, Prolog)

4. **File I/O**: Safe file operations with error handling
   - SaveModel/LoadModel: Model persistence
   - SaveCheckpoint/LoadCheckpoint: Training state persistence
   - Path validation and success indicators

5. **Dataset Operations**: Data loading and preprocessing
   - LoadDataset: Multi-source data loading with validation
   - ShuffleDataset: Random shuffling with seed control
   - SplitDataset: Train/validation splitting

6. **Numerical Stability**: Safeguards against numerical issues
   - ValidateTensor: NaN and Inf detection
   - ClipGradients: Gradient norm clipping
   - Finite value checking

7. **Error Handling**: Robust error management
   - Result type for safe operations
   - Comprehensive error types
   - SafeForward: Example of validated operation

All contracts ensure:
- Pre-condition validation
- Post-condition guarantees
- Error states explicitly handled
- Numerical stability maintained
- Shape compatibility enforced
- Resource management (files, memory)

These contracts define the boundaries between the neural network system
and external systems, ensuring safe and predictable integration.
